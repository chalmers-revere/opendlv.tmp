/*
 * nnRoadSizeCalc.c
 *
 * Code generation for function 'nnRoadSizeCalc'
 *
 * C source code generated on: Sun Feb 02 19:43:17 2014
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "nnRoadAngleCalc.h"
#include "nnRoadSizeCalc.h"
#include "bsxfun.h"

/* Function Definitions */
void nnRoadSizeCalc(const double x1[3], double b_y1[3])
{
  double xp1[9];
  static const double settings_xoffset[3] = { 11.3099, 1.0, 19.0 };

  double b_xp1[9];
  static const double settings_gain[3] = { 0.0127080789070036,
    0.00282087447108604, 0.00701754385964912 };

  double c_xp1[9];
  double b[81];
  int ib;
  int jtilecol;
  int ia;
  int k;
  static const double a[27] = { -3.935477661627147, 3.72973347487971,
    3.1893936654173363, 3.2281610871011654, 3.939571852241091,
    2.9776210880594292, 2.2226343721725748, -1.8461577891264298,
    -1.497655561142315, 1.3489515857743888, -0.22367089718769892,
    0.13644185809112977, -0.53831666374537812, -0.26588946442375588,
    -0.040424371786062417, 0.74527486624950046, 0.8248372934769026,
    1.146749098136411, 1.7705712974652177, -1.8126349906288115,
    -2.2026357890419277, -2.0070759228795847, -3.0116493830637605,
    -3.46222756564268, 3.7648818297347808, -4.0260086028535893,
    -4.0954390533725622 };

  double b_b[81];
  double d1;
  static const double b_a[81] = { 1.8545895861378559, -0.064527608008361409,
    -0.63094749208922873, -1.6304715299954566, -3.3567468821859636,
    -1.5035607782493272, -3.1770188585081445, 2.6919975052973459,
    0.97092264416317153, -4.1805628148322178, 1.6635781048568634,
    -2.5232906889215214, 3.519644309727223, -3.2005517741279119,
    2.5231361700659591, 3.2294606745703311, 4.0332718294327972,
    3.0048677033495945, 1.3534420649057979, -1.0412506067653768,
    -1.72277921885431, 0.037082327882655253, -3.1815212062504528,
    -0.857242507916253, 0.94800024527900473, -2.3111231891461652,
    -3.1402194501034204, -3.4489256554686731, -2.9313447061279851,
    3.7853974878267382, -3.8555486329892825, -0.7801123208726265,
    3.8659764030914654, -0.39831831465527873, -3.1643602501657444,
    -2.8709926441976736, -0.17329336074214313, -2.5447376737518033,
    0.293090252053619, -2.0941560881938619, 2.5439751822259278,
    -0.73214261416392679, 1.7816730158657319, 1.30282831236948,
    1.5454217724557875, 1.5285465365363884, -4.0415729254158927,
    -0.7856474740364191, -3.3745290630388189, 2.0541507751664478,
    -0.7273804461846135, 3.4828444205074667, -2.7785182843889,
    -0.71143633455153676, 1.4651161363215335, 3.0924161204189913,
    2.1454214511286573, -0.27987562151789247, 0.84336596467807123,
    0.10701787304227098, 2.6709997069104845, 0.81823978391689967,
    -3.0787313649971133, -1.2949321876188058, 2.8804487693193024,
    -4.2527210432361757, -0.70050738011995373, 0.64098940256483261,
    3.262626085167597, 1.9217144736671539, -0.38243317051412873,
    -2.5419794614255142, -3.8135442129898425, 0.76365216853990292,
    -3.7845675884875116, 2.5558370188205082, 1.5748400896992094,
    3.7372806123216207, 1.8182965661325743, -1.8555262261424239,
    2.8082281080515665 };

  double x[81];
  double c_y1[3];
  static const double c_a[27] = { 0.43209775108179971, 0.42571519549727205,
    -0.0918533979831059, -0.13921359290474558, -0.63752173976694892,
    0.28919738178955867, -0.097071818433460549, 0.12084591624651202,
    -0.15127231589143866, 0.20335132371576845, 0.28834760758174605,
    0.35297212796007521, -0.099637033622211241, -0.22376289353804485,
    0.28039028597393778, 0.33818052129784265, -0.086668130857837186,
    -0.13669081927710319, 0.37794039821233782, -0.0048184530117766607,
    0.41880346050696993, 0.13087973229941485, 0.085527746022987988,
    -0.2652974396372767, 0.15521920681599516, -0.18384231468289708,
    0.37935708103101973 };

  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 02-Feb-2014 15:38:34. */
  /*   */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = 3xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  bsxfun(x1, settings_xoffset, xp1);
  memcpy(&b_xp1[0], &xp1[0], 9U * sizeof(double));
  b_bsxfun(b_xp1, settings_gain, xp1);
  memcpy(&c_xp1[0], &xp1[0], 9U * sizeof(double));
  c_bsxfun(c_xp1, -1.0, xp1);

  /*  Layer 1 */
  ib = 0;
  for (jtilecol = 0; jtilecol < 3; jtilecol++) {
    ia = 0;
    for (k = 0; k < 27; k++) {
      b[ib] = a[ia];
      ia++;
      ib++;
    }
  }

  /*  Sigmoid Symmetric Transfer Function */
  for (ib = 0; ib < 27; ib++) {
    for (jtilecol = 0; jtilecol < 3; jtilecol++) {
      d1 = 0.0;
      for (k = 0; k < 3; k++) {
        d1 += b_a[ib + 27 * k] * xp1[k + 3 * jtilecol];
      }

      b_b[ib + 27 * jtilecol] = b[ib + 27 * jtilecol] + d1;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      x[jtilecol + 27 * ib] = -2.0 * b_b[jtilecol + 27 * ib];
    }
  }

  for (k = 0; k < 81; k++) {
    x[k] = exp(x[k]);
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      b[jtilecol + 27 * ib] = 2.0 / (1.0 + x[jtilecol + 27 * ib]) - 1.0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    d1 = 0.0;
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      d1 += c_a[jtilecol] * b[jtilecol + 27 * ib];
    }

    c_y1[ib] = 0.30318706972536991 + d1;
  }

  d_bsxfun(c_y1, -1.0, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  e_bsxfun(c_y1, 0.000729660707770887, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  f_bsxfun(c_y1, -592.0, b_y1);
}

/* End of code generation (nnRoadSizeCalc.c) */
