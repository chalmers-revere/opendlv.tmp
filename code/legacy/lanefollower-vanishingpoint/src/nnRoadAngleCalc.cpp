/*
 * nnRoadAngleCalc.c
 *
 * Code generation for function 'nnRoadAngleCalc'
 *
 * C source code generated on: Sun Feb 02 19:43:17 2014
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "nnRoadAngleCalc.h"
#include "nnRoadSizeCalc.h"
#include "bsxfun.h"

/* Function Definitions */
void nnRoadAngleCalc(const double x1[3], double b_y1[3])
{
  double xp1[9];
  static const double settings_xoffset[3] = { 11.3099, 1.0, 19.0 };

  double b_xp1[9];
  static const double settings_gain[3] = { 0.0127080789070036,
    0.00282087447108604, 0.00701754385964912 };

  double c_xp1[9];
  double b[81];
  int ib;
  int jtilecol;
  int ia;
  int k;
  static const double a[27] = { 4.115742546913987, -3.9816606410243072,
    -3.6234955877454329, 3.4392249741348, 3.0769238485405563, 2.256521667923125,
    -2.5947663905936711, 2.875505792002611, 1.6838743186508196,
    1.5626819818143396, 1.097382502811397, 0.404454807877441,
    0.54034180446081392, -0.26997641516823945, 0.13354975553352044,
    -0.87368841031497335, -1.0034630215168499, 0.82187688403705994,
    -1.4323965832818635, -2.1030895217485743, -2.3482308578429807,
    3.00800171540252, 3.0060109708752263, -3.2632088364656409,
    -3.5516829901875373, 3.7824249979323725, -4.2703775896574587 };

  double b_b[81];
  double d0;
  static const double b_a[81] = { -1.6440037191914256, 2.1734073998061323,
    1.1632774871483469, -3.2747305232633392, -0.62338181113749769,
    -4.0037771313684845, 3.0784909422201947, -2.6975264553674867,
    -3.0268739869955352, -1.9330118326420147, -0.67564825184852217,
    -0.40920362018923068, -2.1431210585450269, -1.5921420203913768,
    2.4406579387700638, -4.00950482042803, -2.8300360366052568,
    3.8490634446068275, -2.7625069135849389, -2.9219552653009138,
    -1.9769084384118885, 1.3022693393048972, 1.336134123689567,
    -3.1680162051409719, -2.0028887763209884, 2.5284256445354716,
    -2.5066261298352264, -1.0347743916164087, -3.124711352550996,
    3.6470455310883252, -2.0447859077601485, 3.6995057785508503,
    1.0754235655530058, -1.3910061437018686, 2.2997728816280483,
    2.7200627053563071, -2.0282394073819434, -3.4235222647919685,
    3.7125679175151451, -2.7752485490646004, 3.4974649377982781,
    -2.2908918950693757, 0.84168381254614222, 0.58240991375974971,
    -1.3240216617291738, -2.78000215291438, -1.7273759379400662,
    1.2806062055265965, -1.039922460831274, 2.9824897563799726, 2.68954632660497,
    3.14531381418317, -0.99773641427452753, -1.250499516615265,
    3.7435562416950403, -1.498401700004744, -1.5983043000429134,
    -1.3686085464794113, 1.243906863673601, 1.35765198749039, 2.099758612094222,
    0.50100507219890733, 0.79304260678230587, -2.9659372185700805,
    2.1092323143763232, 1.7134261391953882, 2.2126556791944427,
    -1.6260616100879444, 2.5549118721867949, -0.081509932747494462,
    -2.9871127274515534, -1.2960634547452434, -1.5983525655314346,
    2.3217624362045841, 3.4253534961024736, -3.5203968403541497,
    2.5006624417024983, -0.37115037323929684, -1.9377391731002562,
    -3.3617512478163425, -2.98954490080238 };

  double x[81];
  double c_y1[3];
  static const double c_a[27] = { 0.030821440773736827, 0.58926443719802035,
    0.25834709915359966, -0.49243438638725484, 0.029416268383358216,
    -0.2128685197559379, -0.11064542620295389, 0.46819857183961811,
    -0.090990420755283977, -0.11033553270228313, -0.1026751062967587,
    -0.12134159902114537, 0.1636107600864643, 0.079771036749079385,
    0.36656954786311791, 0.69576542063212488, 0.23060636343706251,
    0.44351723435960766, -0.14656923786400985, 0.18206350799456936,
    -0.055498717707630853, 0.49527010684077705, 0.226924213827104,
    -0.051994885133541766, -0.05409184919711113, -0.6557587782892681,
    0.22575714858710319 };

  /* MYNEURALNETWORKFUNCTION neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 02-Feb-2014 15:42:16. */
  /*   */
  /*  [y1] = myNeuralNetworkFunction(x1) takes these arguments: */
  /*    x = 3xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  bsxfun(x1, settings_xoffset, xp1);
  memcpy(&b_xp1[0], &xp1[0], 9U * sizeof(double));
  b_bsxfun(b_xp1, settings_gain, xp1);
  memcpy(&c_xp1[0], &xp1[0], 9U * sizeof(double));
  c_bsxfun(c_xp1, -1.0, xp1);

  /*  Layer 1 */
  ib = 0;
  for (jtilecol = 0; jtilecol < 3; jtilecol++) {
    ia = 0;
    for (k = 0; k < 27; k++) {
      b[ib] = a[ia];
      ia++;
      ib++;
    }
  }

  /*  Sigmoid Symmetric Transfer Function */
  for (ib = 0; ib < 27; ib++) {
    for (jtilecol = 0; jtilecol < 3; jtilecol++) {
      d0 = 0.0;
      for (k = 0; k < 3; k++) {
        d0 += b_a[ib + 27 * k] * xp1[k + 3 * jtilecol];
      }

      b_b[ib + 27 * jtilecol] = b[ib + 27 * jtilecol] + d0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      x[jtilecol + 27 * ib] = -2.0 * b_b[jtilecol + 27 * ib];
    }
  }

  for (k = 0; k < 81; k++) {
    x[k] = exp(x[k]);
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  for (ib = 0; ib < 3; ib++) {
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      b[jtilecol + 27 * ib] = 2.0 / (1.0 + x[jtilecol + 27 * ib]) - 1.0;
    }
  }

  for (ib = 0; ib < 3; ib++) {
    d0 = 0.0;
    for (jtilecol = 0; jtilecol < 27; jtilecol++) {
      d0 += c_a[jtilecol] * b[jtilecol + 27 * ib];
    }

    c_y1[ib] = 1.1788704574983448 + d0;
  }

  d_bsxfun(c_y1, -1.0, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  e_bsxfun(c_y1, 0.0131076390140486, b_y1);
  for (ib = 0; ib < 3; ib++) {
    c_y1[ib] = b_y1[ib];
  }

  f_bsxfun(c_y1, 9.24222, b_y1);
}

/* End of code generation (nnRoadAngleCalc.c) */
